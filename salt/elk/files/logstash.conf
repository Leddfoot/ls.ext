input {
  stdin {
    type => "stdin-type"
  }

  lumberjack {
    port => {{ pillar['elk']['lumberjack']['port'] }}
    type => "logs"
    ssl_certificate => "/opt/ssl/logstash-forwarder.crt"
    ssl_key => "/opt/ssl/logstash-forwarder.key"
  }
}

filter {
  if [type] == "docker" {
    # Brutal --- removes all logging from the elk container - it logs everything
    if [docker.image] == "pblittle/docker-logstash" {
      drop { }
    } 
  }

  if [type] == "docker" {
    # Brutal --- removes all logging from the forwarder container - it logs too much
    if [docker.name] == "/dockerlogs_forwarder_container" {
      drop { }
    }
  }


  # Lots of stuff comes from docker logs
  if [type] == "docker" {
    # The payload in 'message' splits into 'source.log', 'source.time' and 'source.stream'
    json {
      source => "message"
      target => "source"
    }
  }

  # Remove logging that we're logging ...
  if [type] == "docker" {
    if [docker.image] == "digitalwonderland/logstash-forwarder:latest" {
      if [source][log] =~ /Registrar: pr[oe]cessing \d+ events/ {
        drop { }
      }
    }
  }

  if [type] == "docker" {
    if [docker.name] == "/redef_services_container" {
      if [source][log] =~ "\[JarClassLoader\] INFO\:.*" { # Drop verbose one-jar INFO-logging
        drop { }
      }
    }
  }
  if [type] == "docker" {
    if [docker.name] == "/redef_services_container" {
      json {
        source => "[source][log]"
        target => "log4j"
      }
    }
  }

  if [type] == "docker" {
    if [docker.name] == "/redef_services_container" {
      mutate {
        add_field => {
          "loglevel" => "%{[log4j][level]}"
          "logmessage" => "%{[log4j][message]}"
        }
      }
    }
  }

  # Developed using
  # - http://grokconstructor.appspot.com/
  # - https://github.com/elasticsearch/logstash/blob/master/patterns/grok-patterns
  # A good place to start: match => [ "log", "%{GREEDYDATA:logline}" ]
  if [type] == "docker" {
    if [docker.name] == "/koha_container" {
      grok {
        match => [ 
          "[source][log]", "%{HOST:virtual_host}:%{POSINT:virtual_host_port} %{IPORHOST:clientip} %{USER:ident} %{NOTSPACE:auth} \[%{HTTPDATE:timestamp}\] \"(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})\" %{NUMBER:response} (?:%{NUMBER:bytes}|-) %{QS:referrer};? %{QS:agent}",
          "[source][log]", "\[%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}\] \[%{LOGLEVEL:loglevel}\] \[client %{IPORHOST:client}\] \[%{DAY} %{MONTH} %{MONTHDAY} %{TIME} %{YEAR}\] %{GREEDYDATA:logmessage}",
          "[source][log]", "%{YEAR}(?:0[1-9]|1[0-2])%{MONTHDAY} %{HOUR}:%{MINUTE}:%{SECOND} %{GREEDYDATA:logmessage}",
          "[source][log]", "%{GREEDYDATA:logmessage}"
        ]
      }
    }
  }

  if [type] == "docker" {
    if [docker.name] == "/fuseki_container" {
      grok {
        match => [
          "[source][log]", "%{TIME} %{LOGLEVEL:loglevel}%{SPACE}%{WORD}%{SPACE}::%{SPACE}\[%{NUMBER:req_no}\] %{GREEDYDATA:logmessage}",
          "[source][log]", "%{GREEDYDATA:logmessage}"
        ]
      }
    }
  }

  if [type] == "docker" {
    if [docker.name] == "/redef_catalinker_skeleton_container"  or [docker.name] == "/redef_catalinker_container"{
      grok {
        match => [
          "[source][log]", "%{IPORHOST:clientip} %{USER:ident} %{NOTSPACE:auth} \[%{MONTHDAY}/%{MONTH}/%{YEAR}:%{TIME} %{TZ}\] \"(?:%{WORD:verb}) %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?\" %{NUMBER:response} (?:%{NUMBER:bytes}|-)%{GREEDYDATA}",
          "[source][log]", "%{NOTSPACE:request} %{GREEDYDATA:logmessage}"
        ]
      }
    }
  }


}

output {
  stdout {
    codec => rubydebug
  }

  elasticsearch {
    embedded => true
  }
}
